#pragma once
#include "EngineBase.h"
#include <vector>
#include <array>
#include <complex>
#include <random>

class SpectralGate : public EngineBase {
public:
    SpectralGate();
    ~SpectralGate() override = default;
    
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void process(juce::AudioBuffer<float>& buffer) override;
    void reset() override;
    void updateParameters(const std::map<int, float>& params) override;
    
    int getNumParameters() const override { return 8; }
    juce::String getParameterName(int index) const override;
    juce::String getName() const override { return "Spectral Gate"; }
    
private:
    // Smoothed parameters for boutique quality
    struct SmoothParam {
        float target = 0.5f;
        float current = 0.5f;
        float smoothing = 0.995f;
        
        void update() {
            current = target + (current - target) * smoothing;
        }
        
        void reset(float value) {
            target = current = value;
        }
        
        void setSmoothingTime(float timeMs, float sampleRate) {
            float samples = timeMs * 0.001f * sampleRate;
            smoothing = std::exp(-1.0f / samples);
        }
    };
    
    SmoothParam m_threshold;         // Gate threshold per band
    SmoothParam m_frequency;         // Center frequency (20Hz-20kHz)
    SmoothParam m_bandwidth;         // Frequency range width
    SmoothParam m_attack;            // Attack time
    SmoothParam m_release;           // Release time
    SmoothParam m_sidechain;         // Internal/external sidechain
    SmoothParam m_invert;            // Normal/inverted gating
    SmoothParam m_mix;               // Dry/wet mix
    
    // FFT settings
    static constexpr int FFT_SIZE = 2048;
    static constexpr int FFT_ORDER = 11; // 2^11 = 2048
    static constexpr int OVERLAP_FACTOR = 4;
    static constexpr int HOP_SIZE = FFT_SIZE / OVERLAP_FACTOR;
    
    // Frequency band processing
    struct FrequencyBand {
        int startBin;
        int endBin;
        float threshold;
        float currentGain = 0.0f;
        float targetGain = 0.0f;
        
        // Envelope follower per band
        float envelope = 0.0f;
        float attackCoeff = 0.0f;
        float releaseCoeff = 0.0f;
        
        void updateEnvelope(float magnitude) {
            if (magnitude > envelope) {
                envelope = magnitude + (envelope - magnitude) * attackCoeff;
            } else {
                envelope = magnitude + (envelope - magnitude) * releaseCoeff;
            }
        }
        
        void updateGain(float threshold, bool invert) {
            if (invert) {
                // Inverted mode: gate opens when below threshold
                targetGain = (envelope < threshold) ? 1.0f : 0.0f;
            } else {
                // Normal mode: gate opens when above threshold
                targetGain = (envelope > threshold) ? 1.0f : 0.0f;
            }
            
            // Smooth gain transitions
            const float smoothing = 0.95f;
            currentGain = currentGain * smoothing + targetGain * (1.0f - smoothing);
        }
    };
    
    // FFT processor
    struct FFTProcessor {
        juce::dsp::FFT fft{FFT_ORDER};
        
        std::vector<float> fftBuffer;
        std::vector<std::complex<float>> frequencyData;
        std::vector<float> window;
        
        // Overlap-add buffers
        std::vector<float> inputBuffer;
        std::vector<float> outputBuffer;
        int inputPos = 0;
        int outputPos = 0;
        
        // Frequency bands for gating
        static constexpr int NUM_BANDS = 32;
        std::array<FrequencyBand, NUM_BANDS> bands;
        
        void prepare(double sampleRate) {
            fftBuffer.resize(FFT_SIZE);
            frequencyData.resize(FFT_SIZE);
            window.resize(FFT_SIZE);
            
            inputBuffer.resize(FFT_SIZE);
            outputBuffer.resize(FFT_SIZE);
            
            // Create Hann window
            for (int i = 0; i < FFT_SIZE; ++i) {
                window[i] = 0.5f - 0.5f * std::cos(2.0f * M_PI * i / (FFT_SIZE - 1));
            }
            
            // Initialize frequency bands (logarithmic spacing)
            float nyquist = sampleRate * 0.5f;
            float minFreq = 20.0f;
            float maxFreq = nyquist;
            
            for (int i = 0; i < NUM_BANDS; ++i) {
                float normalizedPos = static_cast<float>(i) / (NUM_BANDS - 1);
                float freq = minFreq * std::pow(maxFreq / minFreq, normalizedPos);
                
                bands[i].startBin = static_cast<int>(freq / nyquist * (FFT_SIZE / 2));
                
                if (i < NUM_BANDS - 1) {
                    float nextFreq = minFreq * std::pow(maxFreq / minFreq, 
                                               static_cast<float>(i + 1) / (NUM_BANDS - 1));
                    bands[i].endBin = static_cast<int>(nextFreq / nyquist * (FFT_SIZE / 2));
                } else {
                    bands[i].endBin = FFT_SIZE / 2;
                }
                
                bands[i].currentGain = 0.0f;
                bands[i].targetGain = 0.0f;
                bands[i].envelope = 0.0f;
            }
            
            reset();
        }
        
        void setEnvelopeParams(float attackMs, float releaseMs, double sampleRate) {
            float frameRate = sampleRate / HOP_SIZE; // Processing frame rate
            
            for (auto& band : bands) {
                band.attackCoeff = std::exp(-1.0f / (attackMs * 0.001f * frameRate));
                band.releaseCoeff = std::exp(-1.0f / (releaseMs * 0.001f * frameRate));
            }
        }
        
        float processSample(float input, float centerFreq, float bandwidth, 
                          float threshold, bool invert, double sampleRate) {
            // Add to input buffer
            inputBuffer[inputPos] = input;
            inputPos = (inputPos + 1) % FFT_SIZE;
            
            // Process when we have enough samples
            if ((inputPos % HOP_SIZE) == 0) {
                processFrame(centerFreq, bandwidth, threshold, invert, sampleRate);
            }
            
            // Read from output buffer
            float output = outputBuffer[outputPos];
            outputBuffer[outputPos] = 0.0f; // Clear after reading
            outputPos = (outputPos + 1) % FFT_SIZE;
            
            return output;
        }
        
        void processFrame(float centerFreq, float bandwidth, float threshold, 
                         bool invert, double sampleRate) {
            // Copy input to FFT buffer with windowing
            for (int i = 0; i < FFT_SIZE; ++i) {
                int idx = (inputPos + i) % FFT_SIZE;
                fftBuffer[i] = inputBuffer[idx] * window[i];
            }
            
            // Forward FFT
            fft.performRealOnlyForwardTransform(fftBuffer.data());
            
            // Copy to complex format for processing
            for (int i = 0; i < FFT_SIZE / 2 + 1; ++i) {
                frequencyData[i] = std::complex<float>(
                    fftBuffer[i * 2],
                    (i > 0 && i < FFT_SIZE / 2) ? fftBuffer[i * 2 + 1] : 0.0f
                );
            }
            
            // Calculate center frequency bin
            float nyquist = sampleRate * 0.5f;
            float actualFreq = 20.0f * std::pow(1000.0f, centerFreq); // 20Hz to 20kHz
            int centerBin = static_cast<int>(actualFreq / nyquist * (FFT_SIZE / 2));
            
            // Calculate bandwidth in bins
            float bwOctaves = 0.1f + bandwidth * 4.9f; // 0.1 to 5 octaves
            float lowFreq = actualFreq / std::pow(2.0f, bwOctaves / 2.0f);
            float highFreq = actualFreq * std::pow(2.0f, bwOctaves / 2.0f);
            int lowBin = std::max(1, static_cast<int>(lowFreq / nyquist * (FFT_SIZE / 2)));
            int highBin = std::min(FFT_SIZE / 2, static_cast<int>(highFreq / nyquist * (FFT_SIZE / 2)));
            
            // Update band envelopes and apply gating
            for (auto& band : bands) {
                // Calculate magnitude for this band
                float magnitude = 0.0f;
                int binCount = 0;
                
                for (int bin = band.startBin; bin < band.endBin && bin <= FFT_SIZE / 2; ++bin) {
                    magnitude += std::abs(frequencyData[bin]);
                    binCount++;
                }
                
                if (binCount > 0) {
                    magnitude /= binCount;
                }
                
                // Update envelope
                band.updateEnvelope(magnitude);
                
                // Check if this band is within the selected frequency range
                bool inRange = (band.startBin <= highBin && band.endBin >= lowBin);
                
                if (inRange) {
                    // Apply gating based on threshold
                    band.updateGain(threshold, invert);
                } else {
                    // Bands outside range always pass through
                    band.targetGain = 1.0f;
                    band.currentGain = 1.0f;
                }
                
                // Apply gain to frequency bins
                for (int bin = band.startBin; bin < band.endBin && bin <= FFT_SIZE / 2; ++bin) {
                    frequencyData[bin] *= band.currentGain;
                }
            }
            
            // Copy back for inverse FFT
            for (int i = 0; i < FFT_SIZE / 2 + 1; ++i) {
                fftBuffer[i * 2] = frequencyData[i].real();
                if (i > 0 && i < FFT_SIZE / 2) {
                    fftBuffer[i * 2 + 1] = frequencyData[i].imag();
                }
            }
            
            // Inverse FFT
            fft.performRealOnlyInverseTransform(fftBuffer.data());
            
            // Add to output buffer with overlap-add
            for (int i = 0; i < FFT_SIZE; ++i) {
                int idx = (outputPos + i) % FFT_SIZE;
                outputBuffer[idx] += fftBuffer[i] * window[i] / (FFT_SIZE * OVERLAP_FACTOR / 2);
            }
        }
        
        void reset() {
            std::fill(inputBuffer.begin(), inputBuffer.end(), 0.0f);
            std::fill(outputBuffer.begin(), outputBuffer.end(), 0.0f);
            std::fill(fftBuffer.begin(), fftBuffer.end(), 0.0f);
            inputPos = 0;
            outputPos = 0;
            
            for (auto& band : bands) {
                band.envelope = 0.0f;
                band.currentGain = 0.0f;
                band.targetGain = 0.0f;
            }
        }
    };
    
    // DC Blocking filter
    struct DCBlocker {
        float x1 = 0.0f, y1 = 0.0f;
        static constexpr float R = 0.995f;
        
        float process(float input) {
            float output = input - x1 + R * y1;
            x1 = input;
            y1 = output;
            return output;
        }
        
        void reset() { x1 = y1 = 0.0f; }
    };
    
    // Thermal modeling for analog drift simulation
    struct ThermalModel {
        float temperature = 25.0f;  // Celsius
        float thermalNoise = 0.0f;
        std::mt19937 rng;
        std::uniform_real_distribution<float> dist{-0.5f, 0.5f};
        
        ThermalModel() : rng(std::random_device{}()) {}
        
        void update(double sampleRate) {
            // Slow thermal drift
            thermalNoise += (dist(rng) * 0.0008f) / sampleRate;
            thermalNoise = std::max(-0.015f, std::min(0.015f, thermalNoise));
        }
        
        float getThermalFactor() const {
            return 1.0f + thermalNoise;
        }
    };
    
    // Component aging simulation
    struct ComponentAging {
        float age = 0.0f;
        float drift = 0.0f;
        float noiseIncrease = 0.0f;
        
        void update(float aging) {
            age = aging;
            drift = aging * 0.012f;  // 1.2% max drift
            noiseIncrease = aging * 0.005f;  // Noise floor degradation
        }
        
        float applyDrift(float value) const {
            return value * (1.0f + drift);
        }
        
        float getNoiseIncrease() const {
            return noiseIncrease;
        }
    };
    
    // Enhanced envelope follower with lookahead
    struct EnhancedEnvelopeFollower {
        static constexpr int LOOKAHEAD_SAMPLES = 64;
        std::array<float, LOOKAHEAD_SAMPLES> lookaheadBuffer;
        int lookaheadIndex = 0;
        
        float envelope = 0.0f;
        float peakHold = 0.0f;
        int peakHoldCounter = 0;
        
        float attackCoeff = 0.0f;
        float releaseCoeff = 0.0f;
        
        void prepare(float attackMs, float releaseMs, double sampleRate) {
            attackCoeff = std::exp(-1.0f / (attackMs * 0.001f * sampleRate));
            releaseCoeff = std::exp(-1.0f / (releaseMs * 0.001f * sampleRate));
            
            std::fill(lookaheadBuffer.begin(), lookaheadBuffer.end(), 0.0f);
            lookaheadIndex = 0;
            envelope = 0.0f;
            peakHold = 0.0f;
            peakHoldCounter = 0;
        }
        
        float process(float input) {
            // Store in lookahead buffer
            lookaheadBuffer[lookaheadIndex] = std::abs(input);
            lookaheadIndex = (lookaheadIndex + 1) % LOOKAHEAD_SAMPLES;
            
            // Find peak in lookahead buffer
            float lookaheadPeak = 0.0f;
            for (float sample : lookaheadBuffer) {
                lookaheadPeak = std::max(lookaheadPeak, sample);
            }
            
            // Enhanced envelope following with peak hold
            float target = lookaheadPeak;
            if (target > envelope) {
                envelope = target + (envelope - target) * attackCoeff;
            } else {
                envelope = target + (envelope - target) * releaseCoeff;
            }
            
            // Peak hold for better transient response
            if (envelope > peakHold) {
                peakHold = envelope;
                peakHoldCounter = static_cast<int>(0.02f * 44100); // 20ms hold
            } else if (peakHoldCounter > 0) {
                peakHoldCounter--;
            } else {
                peakHold *= 0.999f; // Slow decay
            }
            
            return std::max(envelope, peakHold);
        }
    };
    
    // Channel state with enhanced processing
    struct ChannelState {
        FFTProcessor fftProcessor;
        
        // DC blockers for input and output
        DCBlocker inputDCBlocker;
        DCBlocker outputDCBlocker;
        
        // Thermal and aging models
        ThermalModel thermalModel;
        ComponentAging componentAging;
        
        // Enhanced envelope followers per band
        std::array<EnhancedEnvelopeFollower, FFTProcessor::NUM_BANDS> envelopeFollowers;
        
        // Advanced sidechain processing
        struct SidechainProcessor {
            std::vector<float> sidechainBuffer;
            int bufferPos = 0;
            
            void prepare(int maxDelay) {
                sidechainBuffer.resize(maxDelay, 0.0f);
                bufferPos = 0;
            }
            
            float process(float input, float delay) {
                // Store current sample
                sidechainBuffer[bufferPos] = input;
                
                // Calculate delayed read position
                int delayInSamples = static_cast<int>(delay);
                int readPos = (bufferPos - delayInSamples + sidechainBuffer.size()) % sidechainBuffer.size();
                
                bufferPos = (bufferPos + 1) % sidechainBuffer.size();
                
                return sidechainBuffer[readPos];
            }
        };
        
        SidechainProcessor sidechainProcessor;
        
        // Spectral processing enhancement
        struct SpectralEnhancer {
            std::vector<std::complex<float>> previousFrame;
            std::vector<float> spectralSmoothing;
            
            void prepare(int fftSize) {
                previousFrame.resize(fftSize / 2 + 1, std::complex<float>(0.0f, 0.0f));
                spectralSmoothing.resize(fftSize / 2 + 1, 0.0f);
            }
            
            void processSpectralCoherence(std::vector<std::complex<float>>& spectrum) {
                // Enhance spectral coherence and reduce artifacts
                for (size_t i = 0; i < spectrum.size(); ++i) {
                    // Smooth spectral changes
                    float magnitude = std::abs(spectrum[i]);
                    float phase = std::arg(spectrum[i]);
                    
                    // Apply spectral smoothing
                    spectralSmoothing[i] = spectralSmoothing[i] * 0.8f + magnitude * 0.2f;
                    
                    // Phase coherence enhancement
                    float prevPhase = std::arg(previousFrame[i]);
                    float phaseDiff = phase - prevPhase;
                    
                    // Reduce phase discontinuities
                    while (phaseDiff > M_PI) phaseDiff -= 2.0f * M_PI;
                    while (phaseDiff < -M_PI) phaseDiff += 2.0f * M_PI;
                    
                    float smoothedPhase = prevPhase + phaseDiff * 0.9f;
                    spectrum[i] = std::polar(spectralSmoothing[i], smoothedPhase);
                    
                    previousFrame[i] = spectrum[i];
                }
            }
        };
        
        SpectralEnhancer spectralEnhancer;
        
        // Noise floor simulation
        float noiseFloor = -90.0f; // dB
        
        void prepare(double sampleRate) {
            fftProcessor.prepare(sampleRate);
            inputDCBlocker.reset();
            outputDCBlocker.reset();
            
            // Initialize thermal model
            thermalModel = ThermalModel();
            
            // Initialize component aging
            componentAging.update(0.0f);
            
            // Prepare envelope followers
            for (auto& follower : envelopeFollowers) {
                follower.prepare(1.0f, 10.0f, sampleRate); // Default 1ms attack, 10ms release
            }
            
            // Prepare sidechain processor
            sidechainProcessor.prepare(static_cast<int>(sampleRate * 0.1f)); // 100ms max delay
            
            // Prepare spectral enhancer
            spectralEnhancer.prepare(FFT_SIZE);
        }
    };
    
    std::array<ChannelState, 2> m_channelStates;
    double m_sampleRate = 44100.0;
    
    // Latency compensation with lookahead
    int m_latencySamples = 0;
    
    // Component aging tracking
    float m_componentAge = 0.0f;
    int m_sampleCount = 0;
    
    // Enhanced processing flags
    bool m_enableThermalModeling = true;
    bool m_enableComponentAging = true;
    bool m_enableLookahead = true;
    bool m_enableSpectralEnhancement = true;
    
    // Helper methods
    void updateAllSmoothParams();
    void updateComponentAging();
    float applySpectralCharacter(float input, float thermalFactor, float aging);
    
    // Enhanced spectral processing
    void enhanceSpectralQuality(std::vector<std::complex<float>>& spectrum, int channel);
    
    // Advanced gating algorithms
    float calculateAdaptiveThreshold(const std::vector<float>& magnitudes, float baseThreshold);
    void applySpectralSmoothing(std::vector<std::complex<float>>& spectrum, float amount);
};